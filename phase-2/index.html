<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Phase 2 • Dynamic Data Structures | DSA Course</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Outfit:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.2/lib/anime.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="stylesheet" href="../styles.css" />
  </head>
  <body class="lesson-page phase-page">
    <aside
      class="course-drawer"
      id="courseDrawer"
      aria-label="Course navigation"
    >
      <div class="drawer-header">
        <span class="drawer-title">&lt;/&gt; DSA</span>
        <button
          class="drawer-toggle"
          id="drawerToggle"
          aria-label="Collapse navigation"
          aria-expanded="true"
          type="button"
        >
          Hide
        </button>
      </div>
      <div class="drawer-content">
        <div class="drawer-section" data-collapsible>
          <button class="drawer-section-toggle" aria-expanded="false">
            Phase 0: Foundations
            <span class="drawer-chevron" aria-hidden="true">▾</span>
          </button>
          <div class="drawer-links">
            <a href="../phase-0/index.html#phase-0-intro" class="drawer-link"
              >Phase 0: Absolute Foundations</a
            >
            <a href="../phase-0/index.html#lesson-1" class="drawer-link"
              >Lesson 1: What is DSA?</a
            >
            <a href="../phase-0/index.html#lesson-2" class="drawer-link">
              Lesson 2: Time Complexity
            </a>
            <a href="../phase-0/index.html#lesson-3" class="drawer-link">
              Lesson 3: Arrays
            </a>
            <a href="../phase-0/index.html#lesson-4" class="drawer-link">
              Lesson 4: Linear Search
            </a>
          </div>
        </div>
        <div class="drawer-section" data-collapsible>
          <button class="drawer-section-toggle" aria-expanded="false">
            Phase 1: Core Structures
            <span class="drawer-chevron" aria-hidden="true">▾</span>
          </button>
          <div class="drawer-links">
            <a href="../phase-1/index.html#phase-1-intro" class="drawer-link"
              >Phase 1: Sorted Arrays & Binary Search</a
            >
            <a href="../phase-1/index.html#lesson-5" class="drawer-link"
              >Lesson 5: Binary Search</a
            >
            <a href="../phase-1/index.html#lesson-6" class="drawer-link"
              >Lesson 6: Array Insertions & Deletions</a
            >
            <a href="../phase-1/index.html#lesson-7" class="drawer-link"
              >Lesson 7: Space Complexity</a
            >
          </div>
        </div>
        <div class="drawer-section" data-collapsible>
          <button class="drawer-section-toggle" aria-expanded="true">
            Phase 2: Dynamic Data Structures
            <span class="drawer-chevron" aria-hidden="true">▾</span>
          </button>
          <div class="drawer-links">
            <a href="#phase-2-intro" class="drawer-link"
              >Phase 2: Dynamic Data Structures</a
            >
            <a href="#lesson-8" class="drawer-link"
              >Lesson 8: Linked Lists</a
            >
            <a href="#lesson-9" class="drawer-link"
              >Lesson 9: Searching in Linked Lists</a
            >
          </div>
        </div>
      </div>
    </aside>

    <button
      class="drawer-toggle-button"
      id="drawerToggleButton"
      aria-label="Open navigation"
      aria-expanded="true"
      type="button"
    >
      &lt;/&gt; DSA
    </button>

    <main class="main-content">
      <section id="phase-2-intro" data-lesson-section class="phase-header">
        <div class="phase-header-content">
          <span class="phase-badge">Phase 2</span>
          <h2 class="phase-title">Dynamic Data Structures</h2>
          <p class="phase-description">
            Learn data structures that grow and shrink efficiently without the limitations of arrays.
          </p>
          <div class="phase-topics">
            <span class="topic-tag">Linked Lists</span>
            <span class="topic-tag">Pointers</span>
            <span class="topic-tag">Dynamic Memory</span>
            <span class="topic-tag">O(1) Insert/Delete</span>
          </div>
        </div>
      </section>

      <article id="lesson-8" data-lesson-section class="lesson">
        <div class="lesson-header">
          <span class="lesson-number">08</span>
          <h3 class="lesson-title">Linked Lists</h3>
          <p class="lesson-subtitle">Why They Exist</p>
        </div>

        <blockquote class="lesson-intro fade-in">
          Arrays are great for reading. Linked lists are great for writing.
        </blockquote>

        <div class="content-block fade-in">
          <h4>1. The Problem with Arrays</h4>
          <p>From Lesson 6, we learned:</p>
          <ul class="teaches-list">
            <li>
              <span class="bullet">→</span> Inserting into a sorted array →
              <strong>O(n)</strong>
            </li>
            <li>
              <span class="bullet">→</span> Deleting from a sorted array →
              <strong>O(n)</strong>
            </li>
          </ul>
          <p>Why? Because elements must shift.</p>
          <div class="core-idea">
            <p>What if we could insert and delete without shifting?</p>
          </div>
        </div>

        <div class="content-block fade-in">
          <h4>2. What Is a Linked List?</h4>
          <p>
            A linked list is a sequence of <strong>nodes</strong> where each
            node contains:
          </p>
          <ol style="margin-left: 1.5rem">
            <li><strong>Data</strong> — the value</li>
            <li><strong>Pointer</strong> — reference to the next node</li>
          </ol>
          <pre
            class="code-block"
          ><code>[5] → [12] → [8] → [3] → None</code></pre>
          <p>
            Unlike arrays, nodes are <strong>not stored contiguously</strong> in
            memory.
          </p>
        </div>

        <div class="content-block fade-in">
          <h4>3. Why This Matters</h4>
          <div class="space-checklist">
            <div class="space-yes">
              <h5>Arrays</h5>
              <ul>
                <li>Elements live side-by-side</li>
                <li>Inserting means shifting everything after</li>
              </ul>
            </div>
            <div class="space-no">
              <h5>Linked Lists</h5>
              <ul>
                <li>Elements can live anywhere in memory</li>
                <li>Inserting means updating pointers</li>
              </ul>
            </div>
          </div>
          <blockquote class="insight">No shifting required!</blockquote>
        </div>

        <div class="content-block fade-in">
          <h4>4. Linked List Node (Code)</h4>
          <pre
            class="code-block"
          ><code><span class="keyword">class</span> <span class="function">Node</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, value):
        self.value = value
        self.next = <span class="number">None</span></code></pre>
          <p>That's it. A node holds a value and points to the next node.</p>
        </div>

        <div class="content-block fade-in">
          <h4>5. Building a Simple Linked List</h4>
          <pre
            class="code-block"
          ><code><span class="comment"># Create nodes</span>
a = Node(<span class="number">5</span>)
b = Node(<span class="number">12</span>)
c = Node(<span class="number">8</span>)

<span class="comment"># Link them</span>
a.next = b
b.next = c

<span class="comment"># Result: 5 → 12 → 8 → None</span></code></pre>
        </div>

        <div class="content-block fade-in">
          <h4>6. Traversing a Linked List</h4>
          <pre
            class="code-block"
          ><code><span class="keyword">def</span> <span class="function">print_list</span>(head):
    current = head
    <span class="keyword">while</span> current:
        <span class="function">print</span>(current.value)
        current = current.next</code></pre>
          <p>How it works:</p>
          <ul class="teaches-list">
            <li><span class="bullet">→</span> <code>current = head</code> — Start at the first node</li>
            <li><span class="bullet">→</span> <code>while current:</code> — Keep going until we hit <code>None</code> (the end)</li>
            <li><span class="bullet">→</span> <code>current = current.next</code> — Move to the next node</li>
          </ul>
          <p>Think of it like walking through a chain — start at the first link, follow the pointer to the next, repeat until there's no next link.</p>
          <div class="tradeoff-stats">
            <span class="stat">Time: <strong>O(n)</strong></span>
            <span class="stat">Space: <strong>O(1)</strong></span>
          </div>
        </div>

        <div class="content-block fade-in">
          <h4>7. Insertion — The Big Win</h4>
          <p>To insert <code>99</code> after node <code>a</code> (which holds <code>5</code>):</p>
          <pre
            class="code-block"
          ><code>new_node = Node(<span class="number">99</span>)
new_node.next = a.next  <span class="comment"># Step 1: new_node points to what a pointed to (12)</span>
a.next = new_node       <span class="comment"># Step 2: a now points to new_node</span></code></pre>
          <p>Before: <code>5 → 12 → 8</code></p>
          <p>After: <code>5 → 99 → 12 → 8</code></p>
          <div class="core-idea">
            <p><strong>Why this order?</strong> We must save the reference to <code>12</code> before overwriting <code>a.next</code>. If reversed, we'd lose the rest of the chain!</p>
          </div>
          <div class="big-o-reveal">
            <span class="big-o">O(1)</span>
            <span class="label">Just pointer updates — no shifting!</span>
          </div>
        </div>

        <div class="content-block fade-in">
          <h4>8. Deletion — Also Fast</h4>
          <p>To delete the node after <code>a</code>:</p>
          <pre class="code-block"><code>a.next = a.next.next</code></pre>
          <p>Before: <code>5 → 99 → 12 → 8</code></p>
          <p>After: <code>5 → 12 → 8</code></p>
          <div class="big-o-reveal">
            <span class="big-o">O(1)</span>
            <span class="label">Deletion</span>
          </div>
        </div>

        <div class="content-block fade-in">
          <h4>9. The Tradeoff (Important!)</h4>
          <div class="comparison-table">
            <table>
              <thead>
                <tr>
                  <th>Operation</th>
                  <th>Array</th>
                  <th>Linked List</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Access by index</td>
                  <td>O(1)</td>
                  <td>O(n)</td>
                </tr>
                <tr>
                  <td>Insert at position</td>
                  <td>O(n)</td>
                  <td>O(1)*</td>
                </tr>
                <tr>
                  <td>Delete at position</td>
                  <td>O(n)</td>
                  <td>O(1)*</td>
                </tr>
                <tr>
                  <td>Search</td>
                  <td>O(n) or O(log n)</td>
                  <td>O(n)</td>
                </tr>
              </tbody>
            </table>
          </div>
          <p style="font-size: 0.9rem; opacity: 0.8">
            *If you already have a reference to the node.
          </p>
          <div class="core-idea">
            <p>
              Linked lists trade <strong>random access</strong> for
              <strong>fast modifications</strong>.
            </p>
          </div>
        </div>

        <div class="content-block fade-in">
          <h4>10. When to Use Linked Lists</h4>
          <div class="space-checklist">
            <div class="space-yes">
              <h5>Use Linked Lists When</h5>
              <ul>
                <li>Frequent insertions/deletions</li>
                <li>Size changes often</li>
                <li>You don't need random access</li>
              </ul>
            </div>
            <div class="space-no">
              <h5>Use Arrays When</h5>
              <ul>
                <li>Frequent lookups by index</li>
                <li>Data is mostly static</li>
                <li>You need binary search</li>
              </ul>
            </div>
          </div>
        </div>

        <div class="content-block fade-in">
          <h4>11. Types of Linked Lists</h4>
          <ol style="margin-left: 1.5rem">
            <li><strong>Singly Linked</strong> — each node points to next</li>
            <li>
              <strong>Doubly Linked</strong> — each node points to next AND
              previous
            </li>
            <li><strong>Circular</strong> — last node points back to first</li>
          </ol>
          <p>We'll focus on singly linked lists for now.</p>
        </div>

        <div class="content-block fade-in">
          <h4>12. Key Takeaway</h4>
          <div class="highlight-box">
            <p>
              <strong
                >Arrays are optimized for reading. Linked lists are optimized
                for writing.</strong
              >
            </p>
            <p>Neither is "better" — they solve different problems.</p>
          </div>
        </div>

        <div class="content-block fade-in">
          <h4>13. Mental Model</h4>
          <div class="comparison-table">
            <table>
              <thead>
                <tr>
                  <th>Question</th>
                  <th>Array</th>
                  <th>Linked List</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>How is data stored?</td>
                  <td>Contiguous</td>
                  <td>Scattered</td>
                </tr>
                <tr>
                  <td>Fast at?</td>
                  <td>Reading</td>
                  <td>Inserting/Deleting</td>
                </tr>
                <tr>
                  <td>Slow at?</td>
                  <td>Inserting/Deleting</td>
                  <td>Reading by index</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>

        <div class="content-block fade-in">
          <h4>14. LeetCode-Style Question (Lesson 8)</h4>
          <div class="practice-problem">
            <h5>Problem: Search in a Linked List</h5>
            <div class="problem-section">
              <p class="problem-label">Problem Statement</p>
              <p>
                Given the <code>head</code> of a singly linked list and a
                <code>target</code> value, return <code>True</code> if the value
                exists in the list. Otherwise, return <code>False</code>.
              </p>
            </div>
            <div class="problem-section">
              <p class="problem-label">Key Insight</p>
              <ul>
                <li>You must traverse the entire list</li>
                <li>No shortcuts (unlike binary search on arrays)</li>
              </ul>
            </div>
            <div class="problem-section">
              <p class="problem-label">Function Signature</p>
              <pre
                class="code-block"
              ><code><span class="keyword">def</span> <span class="function">search_linked_list</span>(head, target):
    <span class="keyword">pass</span></code></pre>
            </div>
            <div class="problem-section">
              <p class="problem-label">Example</p>
              <pre
                class="code-block"
              ><code><span class="comment"># List: 5 → 12 → 8 → 3 → None</span>

search_linked_list(head, <span class="number">8</span>)   <span class="comment"># Output: True</span>
search_linked_list(head, <span class="number">99</span>)  <span class="comment"># Output: False</span></code></pre>
            </div>
            <div class="problem-section">
              <p class="problem-label">Expected Complexity</p>
              <ul>
                <li>Time: O(n)</li>
                <li>Space: O(1)</li>
              </ul>
            </div>
          </div>
        </div>

        <div class="where-we-are fade-in">
          <h4>Where We Are Now</h4>
          <p>You now understand:</p>
          <ul>
            <li>Why linked lists exist</li>
            <li>How nodes and pointers work</li>
            <li>O(1) insertion and deletion</li>
            <li>The array vs linked list tradeoff</li>
          </ul>
        </div>

        <div class="what-next fade-in">
          <h4>What Comes Next</h4>
          <p>
            You're building the exact intuition strong DSA learners have. Next,
            we'll explore how searching works in linked lists — and why it's
            fundamentally different from arrays.
          </p>
        </div>
      </article>

      <article id="lesson-9" data-lesson-section class="lesson">
        <div class="lesson-header">
          <span class="lesson-number">09</span>
          <h3 class="lesson-title">Searching in Linked Lists</h3>
          <p class="lesson-subtitle">Why You Can't Binary Search a Chain</p>
        </div>

        <blockquote class="lesson-intro fade-in">
          You cannot index into a linked list. The only way in is through the
          front door.
        </blockquote>

        <div class="content-block fade-in">
          <h4>1. Core Rule (Burn This Into Memory)</h4>
          <p>You <strong>cannot</strong> index into a linked list.</p>
          <p>There is no:</p>
          <pre
            class="code-block"
          ><code>linked_list[<span class="number">5</span>]   <span class="comment"># ❌ Not possible</span></code></pre>
          <p>Because:</p>
          <ul class="teaches-list">
            <li>
              <span class="bullet">→</span> Nodes are not stored contiguously
            </li>
            <li>
              <span class="bullet">→</span> Each node only knows the next one
            </li>
          </ul>
          <div class="core-idea">
            <p>The only way to access elements: <strong>Start at head → move step by step.</strong></p>
          </div>
        </div>

        <div class="content-block fade-in">
          <h4>2. What Searching Looks Like</h4>
          <p>Let's define a node first:</p>
          <pre
            class="code-block"
          ><code><span class="keyword">class</span> <span class="function">Node</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, value):
        self.value = value
        self.next = <span class="number">None</span></code></pre>
          <p>Now let's build a list:</p>
          <pre
            class="code-block"
          ><code>[10] → [20] → [30] → [40] → None</code></pre>
          <p>Searching for <code>30</code> means:</p>
          <ol style="margin-left: 1.5rem">
            <li>Check <code>10</code></li>
            <li>Move to <code>20</code></li>
            <li>Move to <code>30</code></li>
            <li>Found</li>
          </ol>
        </div>

        <div class="content-block fade-in">
          <h4>3. Code: Search in Linked List</h4>
          <pre
            class="code-block"
          ><code><span class="keyword">def</span> <span class="function">contains</span>(head, target):
    current = head

    <span class="keyword">while</span> current <span class="keyword">is not</span> <span class="number">None</span>:
        <span class="keyword">if</span> current.value == target:
            <span class="keyword">return</span> <span class="number">True</span>
        current = current.next

    <span class="keyword">return</span> <span class="number">False</span></code></pre>
        </div>

        <div class="content-block fade-in">
          <h4>4. Time Complexity</h4>
          <p>Let <code>n</code> = number of nodes.</p>
          <p><strong>Worst case:</strong></p>
          <ul class="teaches-list">
            <li><span class="bullet">→</span> Target is the last element</li>
            <li><span class="bullet">→</span> Or doesn't exist at all</li>
            <li><span class="bullet">→</span> You traverse the entire list</li>
          </ul>
          <div class="big-o-reveal">
            <span class="big-o">O(n)</span>
            <span class="label">Time — must visit each node</span>
          </div>
        </div>

        <div class="content-block fade-in">
          <h4>5. Space Complexity</h4>
          <p>We only use:</p>
          <ul class="teaches-list">
            <li><span class="bullet">→</span> <code>current</code> — a single pointer variable</li>
            <li><span class="bullet">→</span> No new data structures</li>
          </ul>
          <div class="big-o-reveal">
            <span class="big-o">O(1)</span>
            <span class="label">Space — constant memory</span>
          </div>
        </div>

        <div class="content-block fade-in">
          <h4>6. Compare to Arrays (Critical Thinking Moment)</h4>
          <div class="comparison-table">
            <table>
              <thead>
                <tr>
                  <th>Operation</th>
                  <th>Array</th>
                  <th>Linked List</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Access index</td>
                  <td>O(1)</td>
                  <td>Not possible</td>
                </tr>
                <tr>
                  <td>Linear search</td>
                  <td>O(n)</td>
                  <td>O(n)</td>
                </tr>
                <tr>
                  <td>Binary search</td>
                  <td>O(log n)</td>
                  <td>Not possible</td>
                </tr>
              </tbody>
            </table>
          </div>
          <div class="core-idea">
            <p>
              <strong>Binary search requires random access.</strong>
              Linked lists do not support random access. That alone makes arrays
              superior for searching.
            </p>
          </div>
        </div>

        <div class="content-block fade-in">
          <h4>7. Why Binary Search Fails on Linked Lists</h4>
          <p>Binary search needs:</p>
          <pre
            class="code-block"
          ><code>mid = (left + right) // <span class="number">2</span></code></pre>
          <p>But in a linked list:</p>
          <ul class="teaches-list">
            <li>
              <span class="bullet">→</span> You don't know where "middle" is
            </li>
            <li>
              <span class="bullet">→</span> You must traverse to reach it
            </li>
            <li>
              <span class="bullet">→</span> That traversal alone is
              <strong>O(n)</strong>
            </li>
          </ul>
          <blockquote class="insight">
            Binary search becomes pointless — the traversal to find the midpoint
            costs as much as a linear search.
          </blockquote>
        </div>

        <div class="content-block fade-in">
          <h4>8. Real Insight: The Hidden Cost</h4>
          <div class="space-checklist">
            <div class="space-yes">
              <h5>Arrays</h5>
              <ul>
                <li>Fast lookup</li>
                <li>Cache friendly</li>
              </ul>
            </div>
            <div class="space-no">
              <h5>Linked Lists</h5>
              <ul>
                <li>Pointer chasing</li>
                <li>Memory scattered</li>
                <li>Slower in real machines</li>
              </ul>
            </div>
          </div>
          <blockquote class="insight">
            Linked lists are mostly used in interviews and theory. In practice,
            the hardware favors arrays.
          </blockquote>
        </div>

        <div class="content-block fade-in">
          <h4>9. LeetCode-Style Question (Lesson 9)</h4>
          <div class="practice-problem">
            <h5>Problem: Find Index in Linked List</h5>
            <div class="problem-section">
              <p class="problem-label">Problem Statement</p>
              <p>
                Given the <code>head</code> of a linked list and a
                <code>target</code> value, return the <strong>index</strong> of
                the target. Return <code>-1</code> if it does not exist.
              </p>
            </div>
            <div class="problem-section">
              <p class="problem-label">Function Signature</p>
              <pre
                class="code-block"
              ><code><span class="keyword">def</span> <span class="function">find_index</span>(head, target):
    <span class="keyword">pass</span></code></pre>
            </div>
            <div class="problem-section">
              <p class="problem-label">Example</p>
              <pre
                class="code-block"
              ><code><span class="comment"># List: 10 → 20 → 30 → 40 → None</span>

find_index(head, <span class="number">30</span>)   <span class="comment"># Output: 2</span>
find_index(head, <span class="number">99</span>)   <span class="comment"># Output: -1</span></code></pre>
            </div>
            <div class="problem-section">
              <p class="problem-label">Key Insight</p>
              <ul>
                <li>You must count while traversing</li>
              </ul>
            </div>
            <div class="problem-section">
              <p class="problem-label">Expected Complexity</p>
              <ul>
                <li>Time: O(n)</li>
                <li>Space: O(1)</li>
              </ul>
            </div>
          </div>
        </div>

        <div class="content-block fade-in">
          <h4>10. Deep Takeaway</h4>
          <div class="highlight-box">
            <p>Linked lists trade:</p>
            <ul>
              <li>Memory locality</li>
              <li>Indexing speed</li>
              <li>Binary search ability</li>
            </ul>
            <p>For:</p>
            <ul>
              <li>Fast insertions</li>
              <li>No shifting</li>
            </ul>
            <p><strong>But in practice, arrays often win.</strong></p>
          </div>
        </div>

        <div class="where-we-are fade-in">
          <h4>Where We Are Now</h4>
          <p>You now understand:</p>
          <ul>
            <li>Why you can't binary search a linked list</li>
            <li>How linear search works on linked lists</li>
            <li>The real-world performance gap between arrays and linked lists</li>
          </ul>
        </div>

        <div class="what-next fade-in">
          <h4>What Comes Next</h4>
          <p>
            <strong>Lesson 10: Stacks — LIFO Thinking.</strong> This is where
            linked lists become useful again.
          </p>
        </div>
      </article>
    </main>

    <script src="../app.js"></script>
    <script src="../visualizations.js"></script>
  </body>
</html>
