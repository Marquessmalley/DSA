# DSA Course Roadmap (Beginner → Confident)

## Phase 0: Absolute Foundations

*Thinking tools before "real" DSA*

### Lesson 1: What Is DSA, Really?

- Data Structures vs Algorithms
- Real-world intuition
- Performance mindset

### Lesson 2: Time Complexity (Big-O) — Zero-Math Version

- What Big-O measures
- O(1), O(n), O(n²)
- Reading complexity from code

### Lesson 3: Arrays (Python Lists) — First Data Structure

- What arrays are
- Indexing vs traversal
- Common operations & cost

### Lesson 4: Linear Search — First Algorithm

- Step-by-step searching
- Best vs worst case
- Why O(n) exists

## Phase 1: Improving on the Basics

*Same data, better algorithms*

### Lesson 5: Sorted Arrays & Binary Search

- Why sorting matters
- Binary search intuition
- O(log n) explained visually

### Lesson 6: Array Insertions & Deletions

- Why middle inserts are slow
- Shifting elements
- Performance trade-offs

### Lesson 7: Space Complexity (Gentle Introduction)

- What memory cost means
- Time vs space trade-offs
- Common beginner mistakes

## Phase 2: Dynamic Data Structures

*When arrays stop being enough*

### Lesson 8: Linked Lists — Why They Exist

- Nodes and pointers
- Insert/delete advantages
- Why they're rare in real apps

### Lesson 9: Searching in Linked Lists

- Traversal cost
- Comparison with arrays
- Trade-offs revisited

### Lesson 10: Stacks — LIFO Thinking

- Call stack intuition
- Push / pop
- Valid parentheses problem

### Lesson 11: Queues — FIFO Thinking

- Task scheduling
- Breadth-first intuition
- Queue vs stack comparison

## Phase 3: Hashing & Fast Lookups

*The most important real-world phase*

### Lesson 12: Hash Maps (Dictionaries)

- Key → value idea
- Why lookups are fast
- O(1) average time

### Lesson 13: Hash Collisions (No Math Pain)

- Why collisions happen
- Buckets & chaining
- Why performance usually survives

### Lesson 14: Hash-Based Algorithms

- Two-sum problem
- Frequency counting
- Deduplication patterns

## Phase 4: Recursion & Divide-and-Conquer

*Thinking differently about problems*

### Lesson 15: Recursion Demystified

- Base case & recursive case
- Call stack visualization
- Common mistakes

### Lesson 16: Divide and Conquer

- Breaking problems down
- Merge sort intuition
- Why recursion helps

## Phase 5: Trees

*Hierarchical data everywhere*

### Lesson 17: Trees — Core Concepts

- Nodes, edges, root, leaves
- File systems & DOM

### Lesson 18: Binary Trees & Traversals

- In-order / pre-order / post-order
- DFS intuition

### Lesson 19: Binary Search Trees (BST)

- Why ordered trees matter
- Search, insert, delete
- BST vs arrays

## Phase 6: Sorting Algorithms

*Where performance intuition gets sharp*

### Lesson 20: Why Sorting Is Harder Than It Looks

- Stability
- In-place vs extra memory
- Comparison limits

### Lesson 21: Bubble, Selection & Insertion Sort

- Simple but slow
- O(n²) intuition

### Lesson 22: Merge Sort

- Divide-and-conquer sorting
- O(n log n)
- Why it scales

### Lesson 23: Quick Sort (Conceptual)

- Partitioning idea
- Average vs worst case
- Why it's fast in practice

## Phase 7: Graphs

*The most powerful (and feared) structure*

### Lesson 24: Graph Basics

- Nodes & edges
- Directed vs undirected
- Real-world examples

### Lesson 25: Graph Traversal

- BFS vs DFS
- Shortest paths intuition
- Cycle detection

## Phase 8: Problem-Solving Patterns

*Turning knowledge into skill*

### Lesson 26: Two-Pointer Technique

- Sorted array problems
- Reducing O(n²) to O(n)

### Lesson 27: Sliding Window

- Subarrays
- Optimization patterns

### Lesson 28: Common Interview Traps

- Off-by-one errors
- Misusing data structures
- Thinking before coding

---

## Final Outcome

By the end, you will be able to:

- Look at code and predict performance
- Choose the right data structure
- Explain trade-offs clearly
- Solve DSA problems calmly and methodically
