<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Phase 1 ‚Ä¢ Core Structures | DSA Course</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Outfit:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.2/lib/anime.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="stylesheet" href="../styles.css" />
  </head>
  <body class="lesson-page phase-page">
    <aside
      class="course-drawer"
      id="courseDrawer"
      aria-label="Course navigation"
    >
      <div class="drawer-header">
        <span class="drawer-title">&lt;/&gt; DSA</span>
        <button
          class="drawer-toggle"
          id="drawerToggle"
          aria-label="Collapse navigation"
          aria-expanded="true"
          type="button"
        >
          Hide
        </button>
      </div>
      <div class="drawer-content">
        <div class="drawer-section" data-collapsible>
          <button class="drawer-section-toggle" aria-expanded="false">
            Phase 0: Foundations
            <span class="drawer-chevron" aria-hidden="true">‚ñæ</span>
          </button>
          <div class="drawer-links">
            <a href="../phase-0/index.html#phase-0-intro" class="drawer-link"
              >Phase 0: Absolute Foundations</a
            >
            <a href="../phase-0/index.html#lesson-1" class="drawer-link"
              >Lesson 1: What is DSA?</a
            >
            <a href="../phase-0/index.html#lesson-2" class="drawer-link">
              Lesson 2: Time Complexity
            </a>
            <a href="../phase-0/index.html#lesson-3" class="drawer-link">
              Lesson 3: Arrays
            </a>
            <a href="../phase-0/index.html#lesson-4" class="drawer-link">
              Lesson 4: Linear Search
            </a>
          </div>
        </div>
        <div class="drawer-section" data-collapsible>
          <button class="drawer-section-toggle" aria-expanded="true">
            Phase 1: Core Structures
            <span class="drawer-chevron" aria-hidden="true">‚ñæ</span>
          </button>
          <div class="drawer-links">
            <a href="#phase-1-intro" class="drawer-link"
              >Phase 1: Sorted Arrays & Binary Search</a
            >
            <a href="#lesson-5" class="drawer-link">Lesson 5: Binary Search</a>
            <a href="#lesson-6" class="drawer-link"
              >Lesson 6: Array Insertions & Deletions</a
            >
            <a href="#lesson-7" class="drawer-link"
              >Lesson 7: Space Complexity</a
            >
            <a href="#lesson-8" class="drawer-link"
              >Lesson 8: Linked Lists</a
            >
          </div>
        </div>
        <div class="drawer-section drawer-section-locked">
          <div class="drawer-section-label">Phase 2: Algorithms</div>
          <div class="drawer-section-status">Coming Soon</div>
        </div>
      </div>
    </aside>

    <button
      class="drawer-toggle-button"
      id="drawerToggleButton"
      aria-label="Open navigation"
      aria-expanded="true"
      type="button"
    >
      &lt;/&gt; DSA
    </button>

    <main class="main-content">
      <section id="phase-1-intro" data-lesson-section class="phase-header">
        <div class="phase-header-content">
          <span class="phase-badge">Phase 1</span>
          <h2 class="phase-title">Sorted Arrays & Binary Search</h2>
          <p class="phase-description">
            Discover how organizing data unlocks dramatically faster algorithms.
          </p>
          <div class="phase-topics">
            <span class="topic-tag">Sorted Arrays</span>
            <span class="topic-tag">Binary Search</span>
            <span class="topic-tag">O(log n) Time</span>
            <span class="topic-tag">Trade-offs</span>
          </div>
        </div>
      </section>

      <article id="lesson-5" data-lesson-section class="lesson lesson-alt">
        <div class="lesson-header">
          <span class="lesson-number">05</span>
          <h3 class="lesson-title">Sorted Arrays &amp; Binary Search</h3>
          <p class="lesson-subtitle">
            To go faster, we must give something up.
          </p>
        </div>

        <blockquote class="lesson-intro fade-in">
          So far, we've been searching like this: "Check every element until we
          find it." That works ‚Äî but it's slow at scale. Binary search asks a
          different question: "What if the data were organized?"
        </blockquote>

        <div class="content-block fade-in">
          <h4>1. What Is Binary Search?</h4>
          <p>
            Binary search is a <strong>searching algorithm</strong> that works
            on sorted arrays.
          </p>
          <div class="core-idea">
            <p>
              It repeatedly divides the search space in half until the target is
              found (or proven not to exist).
            </p>
          </div>
          <p>The key insight:</p>
          <ul class="teaches-list">
            <li>
              <span class="bullet">‚Üí</span> Each comparison
              <strong>eliminates half the remaining elements</strong>
            </li>
            <li>
              <span class="bullet">‚Üí</span> This leads to O(log n) time
              complexity
            </li>
            <li>
              <span class="bullet">‚Üí</span> Vastly faster than linear search for
              large datasets
            </li>
          </ul>
        </div>

        <div class="content-block fade-in">
          <h4>2. The Cost of Speed (Important Trade-off)</h4>
          <p>Binary search only works if the array is sorted.</p>
          <pre
            class="code-block"
          ><code><span class="keyword">numbers</span> = [<span class="number">3</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">18</span>, <span class="number">25</span>, <span class="number">31</span>]</code></pre>
          <p>That's the price we pay:</p>
          <ul class="teaches-list">
            <li><span class="bullet">‚Üí</span> We must keep data sorted</li>
            <li><span class="bullet">‚Üí</span> Insertions become harder</li>
            <li>
              <span class="bullet">‚Üí</span> But searches become much faster
            </li>
          </ul>
          <div class="core-idea">
            <p>üëâ This is a classic DSA trade-off.</p>
          </div>
        </div>

        <div class="content-block fade-in">
          <h4>3. Intuition Before Code</h4>
          <p>Imagine guessing a number between 1 and 100.</p>
          <p>You don't start at 1. You guess 50.</p>
          <p>Then:</p>
          <ul class="teaches-list">
            <li><span class="bullet">‚Üí</span> If too high ‚Üí go left</li>
            <li><span class="bullet">‚Üí</span> If too low ‚Üí go right</li>
          </ul>
          <p>Each guess eliminates half the possibilities.</p>
          <blockquote class="insight">That's binary search.</blockquote>
        </div>

        <div class="content-block fade-in">
          <h4>4. How Binary Search Works (Step by Step)</h4>
          <p>Given:</p>
          <pre
            class="code-block"
          ><code><span class="keyword">numbers</span> = [<span class="number">3</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">18</span>, <span class="number">25</span>, <span class="number">31</span>]
<span class="keyword">target</span> = <span class="number">18</span></code></pre>
          <p>Steps:</p>
          <ol style="margin-left: 1.5rem">
            <li>Look at the middle element ‚Üí 18</li>
            <li>Is it the target?</li>
            <li>Yes ‚Üí done</li>
          </ol>
          <p>Worst case:</p>
          <ul class="teaches-list">
            <li><span class="bullet">‚Üí</span> You cut the array in half</li>
            <li><span class="bullet">‚Üí</span> Then in half again</li>
            <li><span class="bullet">‚Üí</span> Then again‚Ä¶</li>
          </ul>
        </div>

        <div class="content-block fade-in">
          <h4>5. Binary Search Code (Iterative)</h4>
          <pre
            class="code-block"
          ><code><span class="keyword">def</span> <span class="function">binary_search</span>(arr, target):
    left = <span class="number">0</span>
    right = <span class="function">len</span>(arr) - <span class="number">1</span>

    <span class="keyword">while</span> left &lt;= right:
        mid = (left + right) // <span class="number">2</span>

        <span class="keyword">if</span> arr[mid] == target:
            <span class="keyword">return</span> <span class="number">True</span>
        <span class="keyword">elif</span> arr[mid] &lt; target:
            left = mid + <span class="number">1</span>
        <span class="keyword">else</span>:
            right = mid - <span class="number">1</span>

    <span class="keyword">return</span> <span class="number">False</span></code></pre>
          <p>Don't worry about memorizing this. Focus on the idea.</p>

          <h5 style="margin-top: 1.5rem">Try It Yourself</h5>
          <p>
            Watch binary search in action. Click Play or Step through each
            comparison:
          </p>
          <div id="binary-search-viz"></div>
        </div>

        <div class="content-block fade-in">
          <h4>üß© Practice Set 1: Arrays & Searching</h4>
          <div class="practice-problem">
            <h5>Problem 2: Binary Search (Beginner)</h5>
            <div class="problem-section">
              <p class="problem-label">üìå Problem Statement</p>
              <p>
                You are given a sorted array of integers <code>nums</code> and an
                integer <code>target</code>.
              </p>
              <p>
                Return the index of <code>target</code> if it exists. Otherwise,
                return <code>-1</code>.
              </p>
            </div>
            <div class="problem-section">
              <p class="problem-label">üß† What This Tests</p>
              <ul>
                <li>Binary search logic</li>
                <li>Understanding sorted data</li>
                <li>O(log n) thinking</li>
              </ul>
            </div>
            <div class="problem-section">
              <p class="problem-label">‚úçÔ∏è Function Signature</p>
              <pre
                class="code-block"
              ><code><span class="keyword">def</span> <span class="function">binary_search</span>(nums, target):
    <span class="keyword">pass</span></code></pre>
            </div>
            <div class="problem-section">
              <p class="problem-label">üß™ Example</p>
              <pre
                class="code-block"
              ><code>nums = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>]
target = <span class="number">7</span>

<span class="comment"># Output: 3</span></code></pre>
            </div>
            <div class="problem-section">
              <p class="problem-label">üß≠ Constraints</p>
              <ul>
                <li><code>1 ‚â§ len(nums) ‚â§ 10‚Åµ</code></li>
                <li><code>nums</code> is sorted in ascending order</li>
                <li>No duplicate elements</li>
              </ul>
            </div>
            <div class="problem-section">
              <p class="problem-label">üí° Hints</p>
              <ul>
                <li>Track left and right</li>
                <li>Eliminate half each step</li>
              </ul>
            </div>
            <div class="problem-section">
              <p class="problem-label">‚è± Expected Complexity</p>
              <ul>
                <li>Time: O(log n)</li>
                <li>Space: O(1)</li>
              </ul>
            </div>
          </div>
        </div>
      </article>

      <article id="lesson-6" data-lesson-section class="lesson">
        <div class="lesson-header">
          <span class="lesson-number">06</span>
          <h3 class="lesson-title">Array Insertions & Deletions</h3>
          <p class="lesson-subtitle">
            The Hidden Cost of Maintaining Sorted Arrays
          </p>
        </div>

        <div class="lesson-intro fade-in">
          <p>
            Binary search is fast ‚Äî but sorted arrays are expensive to maintain.
          </p>
        </div>

        <div class="content-block fade-in">
          <h4>1. The Core Trade-off</h4>
          <p>From Lesson 5, we learned:</p>
          <div class="highlight-box">
            <p>
              <strong>Sorted arrays + binary search ‚Üí O(log n) search</strong>
            </p>
          </div>
          <p>
            But arrays are stored contiguously. That combination creates a
            problem.
          </p>
        </div>

        <div class="content-block fade-in">
          <h4>2. Why Arrays Are Fast (Reminder)</h4>
          <p>Arrays are fast because:</p>
          <ul>
            <li>Elements live next to each other in memory</li>
            <li>Index access is O(1)</li>
            <li>Jumping to <code>arr[i]</code> is instant</li>
          </ul>
          <p>But that same property causes trouble.</p>
        </div>

        <div class="content-block fade-in">
          <h4>3. Inserting into a Sorted Array</h4>
          <p>Suppose we have a sorted array:</p>
          <div class="code-block">
            <pre><code>numbers = [3, 7, 12, 18, 25]</code></pre>
          </div>
          <p>We want to insert 10.</p>

          <h5>Step 1: Find the correct position</h5>
          <p>Binary search can do this in: <strong>O(log n)</strong></p>
          <p>So far so good.</p>

          <h5>Step 2: Make space (This Is the Problem)</h5>
          <p>To insert 10, the array must become:</p>
          <div class="code-block">
            <pre><code>[3, 7, 10, 12, 18, 25]</code></pre>
          </div>
          <p>What must happen internally:</p>
          <ul>
            <li>12, 18, and 25 shift one position right</li>
            <li>Multiple assignments occur</li>
            <li>If the array has n elements: Up to n elements may shift</li>
          </ul>
          <div class="big-o-reveal">
            <span class="big-o">O(n)</span>
            <span class="label">Insertion</span>
          </div>
        </div>

        <div class="content-block fade-in">
          <h4>4. Deleting from a Sorted Array</h4>
          <p>Now remove 7:</p>
          <div class="code-block">
            <pre><code>numbers = [3, 7, 12, 18, 25]</code></pre>
          </div>
          <p>After deletion:</p>
          <div class="code-block">
            <pre><code>[3, 12, 18, 25]</code></pre>
          </div>
          <p>What happens:</p>
          <ul>
            <li>Elements after 7 shift left</li>
            <li>Again, many assignments</li>
          </ul>
          <div class="big-o-reveal">
            <span class="big-o">O(n)</span>
            <span class="label">Deletion</span>
          </div>
        </div>

        <div class="content-block fade-in">
          <h4>5. Why Binary Search Can't Fix This</h4>
          <p>Binary search helps you:</p>
          <ul>
            <li>Find where to insert or delete</li>
          </ul>
          <p>But it cannot:</p>
          <ul>
            <li>Move memory faster</li>
            <li>Avoid shifting elements</li>
          </ul>
          <div class="highlight-box">
            <p><strong>Searching is fast. Shifting is slow.</strong></p>
          </div>
        </div>

        <div class="content-block fade-in">
          <h4>6. The Real Cost of "Sorted Arrays"</h4>
          <p>Let's summarize operations:</p>
          <div class="comparison-table">
            <table>
              <thead>
                <tr>
                  <th>Operation</th>
                  <th>Time</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Search</td>
                  <td>O(log n)</td>
                </tr>
                <tr>
                  <td>Insert</td>
                  <td>O(n)</td>
                </tr>
                <tr>
                  <td>Delete</td>
                  <td>O(n)</td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>So sorted arrays are:</p>
          <ul>
            <li>Excellent for read-heavy systems</li>
            <li>Bad for write-heavy systems</li>
          </ul>
        </div>

        <div class="content-block fade-in">
          <h4>7. Real-World Analogy</h4>
          <p>Think of a row of numbered lockers:</p>
          <p>Looking up locker #500 ‚Üí instant</p>
          <p>Adding a locker in the middle ‚Üí everyone shifts</p>
          <p>That's a sorted array.</p>
        </div>

        <div class="content-block fade-in">
          <h4>8. When Sorted Arrays Make Sense</h4>
          <p>Use them when:</p>
          <ul>
            <li>Searches are frequent</li>
            <li>Inserts/deletes are rare</li>
            <li>Data is mostly static</li>
          </ul>
          <p>Examples:</p>
          <ul>
            <li>Dictionaries</li>
            <li>Static configuration data</li>
            <li>Read-only datasets</li>
          </ul>
        </div>

        <div class="content-block fade-in">
          <h4>9. When Sorted Arrays Are a Bad Fit</h4>
          <p>Avoid them when:</p>
          <ul>
            <li>Data changes constantly</li>
            <li>Insertions/deletions are frequent</li>
            <li>Order must be maintained dynamically</li>
          </ul>
          <p>This leads us to new data structures.</p>
        </div>

        <div class="content-block fade-in">
          <h4>10. Key Takeaway (Lock This In)</h4>
          <div class="highlight-box">
            <p>
              <strong
                >Binary search is fast, but keeping data sorted is
                expensive.</strong
              >
            </p>
          </div>
          <p>DSA is always about trade-offs.</p>
        </div>

        <div class="where-we-are fade-in">
          <h4>üß≠ Where We Are Now</h4>
          <p>You now understand:</p>
          <ul>
            <li>Why binary search is powerful</li>
            <li>Why it's not free</li>
            <li>Why arrays aren't always enough</li>
          </ul>
          <p>This sets the stage for dynamic data structures.</p>
        </div>

        <div class="what-next fade-in">
          <h4>üîú What Comes Next</h4>
          <p>
            Before we move to new data structures, let's understand
            <strong>space complexity</strong> ‚Äî the other half of algorithm
            analysis.
          </p>
          <div class="cta-button">
            <a href="#lesson-7">Start Lesson 7 ‚Üí</a>
          </div>
        </div>
      </article>

      <article id="lesson-7" data-lesson-section class="lesson lesson-alt">
        <div class="lesson-header">
          <span class="lesson-number">07</span>
          <h3 class="lesson-title">Space Complexity</h3>
          <p class="lesson-subtitle">
            Beginner-Friendly ‚Äî No Math Required
          </p>
        </div>

        <blockquote class="lesson-intro fade-in">
          If time complexity is "how long does it take?" ‚Äî space complexity is
          "how much extra memory does it use?" We'll keep this intuitive.
        </blockquote>

        <div class="content-block fade-in">
          <h4>1. What Is Space Complexity?</h4>
          <p>
            Space complexity measures the memory an algorithm adds.
          </p>
          <div class="core-idea">
            <p>We care about <strong>extra space</strong>, not the input itself.</p>
          </div>
        </div>

        <div class="content-block fade-in">
          <h4>2. What Counts as "Extra Space"?</h4>
          <div class="space-checklist">
            <div class="space-yes">
              <h5>Counts</h5>
              <ul>
                <li>Variables</li>
                <li>New arrays / lists</li>
                <li>Hash maps / sets</li>
                <li>Recursive call stack</li>
              </ul>
            </div>
            <div class="space-no">
              <h5>Doesn't Count</h5>
              <ul>
                <li>The input array itself</li>
                <li>Constants (fixed number of variables)</li>
              </ul>
            </div>
          </div>
        </div>

        <div class="content-block fade-in">
          <h4>3. Constant Space ‚Äî O(1)</h4>
          <p>Example: Your Binary Search from Lesson 5</p>
          <pre
            class="code-block"
          ><code><span class="keyword">def</span> <span class="function">binary_search</span>(nums, target):
    left = <span class="number">0</span>
    right = <span class="function">len</span>(nums) - <span class="number">1</span>

    <span class="keyword">while</span> left &lt;= right:
        mid = (left + right) // <span class="number">2</span>
        <span class="keyword">if</span> nums[mid] == target:
            <span class="keyword">return</span> mid
        <span class="keyword">elif</span> nums[mid] &lt; target:
            left = mid + <span class="number">1</span>
        <span class="keyword">else</span>:
            right = mid - <span class="number">1</span>

    <span class="keyword">return</span> <span class="number">-1</span></code></pre>
          <p>Extra memory used: <code>left</code>, <code>right</code>, <code>mid</code></p>
          <p>That's three integers, no matter how big <code>nums</code> is.</p>
          <div class="big-o-reveal">
            <span class="big-o">O(1)</span>
            <span class="label">Constant Space</span>
          </div>
        </div>

        <div class="content-block fade-in">
          <h4>4. Linear Space ‚Äî O(n)</h4>
          <p>Example: Creating a New Array</p>
          <pre
            class="code-block"
          ><code><span class="keyword">def</span> <span class="function">copy_array</span>(nums):
    result = []
    <span class="keyword">for</span> n <span class="keyword">in</span> nums:
        result.append(n)
    <span class="keyword">return</span> result</code></pre>
          <p>
            If <code>nums</code> has <strong>n</strong> elements,
            <code>result</code> also has <strong>n</strong> elements.
            Memory grows linearly.
          </p>
          <div class="big-o-reveal">
            <span class="big-o">O(n)</span>
            <span class="label">Linear Space</span>
          </div>
        </div>

        <div class="content-block fade-in">
          <h4>5. Space vs Time Tradeoff (Very Important)</h4>
          <p>Consider two approaches to checking if a value exists:</p>

          <h5 style="margin-top: 1.5rem">Linear Search</h5>
          <pre
            class="code-block"
          ><code><span class="keyword">def</span> <span class="function">contains</span>(nums, target):
    <span class="keyword">for</span> n <span class="keyword">in</span> nums:
        <span class="keyword">if</span> n == target:
            <span class="keyword">return</span> <span class="number">True</span>
    <span class="keyword">return</span> <span class="number">False</span></code></pre>
          <div class="tradeoff-stats">
            <span class="stat">Time: <strong>O(n)</strong></span>
            <span class="stat">Space: <strong>O(1)</strong></span>
          </div>

          <h5 style="margin-top: 1.5rem">Using a Set for Faster Lookup</h5>
          <pre
            class="code-block"
          ><code><span class="keyword">def</span> <span class="function">contains_fast</span>(nums, target):
    lookup = <span class="function">set</span>(nums)
    <span class="keyword">return</span> target <span class="keyword">in</span> lookup</code></pre>
          <div class="tradeoff-stats">
            <span class="stat">Time: <strong>O(1)</strong> average lookup</span>
            <span class="stat">Space: <strong>O(n)</strong> extra memory</span>
          </div>

          <div class="core-idea" style="margin-top: 1.5rem">
            <p>
              This is a classic DSA tradeoff: <strong>faster time ‚Üí more
              memory</strong>. <strong>Less memory ‚Üí slower time</strong>.
            </p>
          </div>
        </div>

        <div class="content-block fade-in">
          <h4>6. Recursion Uses Space (Hidden!)</h4>
          <pre
            class="code-block"
          ><code><span class="keyword">def</span> <span class="function">print_all</span>(nums, i=<span class="number">0</span>):
    <span class="keyword">if</span> i == <span class="function">len</span>(nums):
        <span class="keyword">return</span>
    <span class="function">print</span>(nums[i])
    print_all(nums, i + <span class="number">1</span>)</code></pre>
          <p>
            Each recursive call sits on the <strong>call stack</strong> and
            takes memory. If there are <strong>n</strong> elements:
          </p>
          <div class="big-o-reveal">
            <span class="big-o">O(n)</span>
            <span class="label">Stack Space</span>
          </div>
          <blockquote class="insight">
            Even though you didn't create an array!
          </blockquote>
        </div>

        <div class="content-block fade-in">
          <h4>7. How LeetCode Expects You to Think</h4>
          <p>When asked: "What's the space complexity?"</p>
          <p>Ask yourself:</p>
          <ul class="teaches-list">
            <li>
              <span class="bullet">‚Üí</span> Did I create new data structures?
            </li>
            <li>
              <span class="bullet">‚Üí</span> Does memory grow with input?
            </li>
            <li>
              <span class="bullet">‚Üí</span> Is recursion involved?
            </li>
          </ul>
        </div>

        <div class="content-block fade-in">
          <h4>8. Common Beginner Confusions</h4>
          <div class="confusion-list">
            <div class="confusion-item">
              <p class="confusion-wrong">"I used a loop so space is O(n)"</p>
              <p class="confusion-right">Loops don't cost memory ‚Äî variables do</p>
            </div>
            <div class="confusion-item">
              <p class="confusion-wrong">"The input array counts"</p>
              <p class="confusion-right">Input is free</p>
            </div>
            <div class="confusion-item">
              <p class="confusion-wrong">"Python hides memory so I can't analyze it"</p>
              <p class="confusion-right">Big-O ignores language details</p>
            </div>
          </div>
        </div>

        <div class="content-block fade-in">
          <h4>9. Practice Problem: Contains Duplicate</h4>
          <div class="practice-problem">
            <h5>Problem 3: Contains Duplicate</h5>
            <div class="problem-section">
              <p class="problem-label">Problem Statement</p>
              <p>
                Given an array <code>nums</code>, return <code>True</code> if
                any value appears at least twice.
              </p>
            </div>
            <div class="problem-section">
              <p class="problem-label">Brute Force (Don't Code Yet)</p>
              <ul>
                <li>Nested loops</li>
                <li>Time: O(n¬≤)</li>
                <li>Space: O(1)</li>
              </ul>
            </div>
            <div class="problem-section">
              <p class="problem-label">Optimized Idea</p>
              <ul>
                <li>Use a set</li>
                <li>Time: O(n)</li>
                <li>Space: O(n)</li>
              </ul>
            </div>
            <div class="problem-section">
              <p class="problem-label">Function Signature</p>
              <pre
                class="code-block"
              ><code><span class="keyword">def</span> <span class="function">contains_duplicate</span>(nums):
    <span class="keyword">pass</span></code></pre>
            </div>
            <div class="problem-section">
              <p class="problem-label">Example</p>
              <pre
                class="code-block"
              ><code>nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]
<span class="comment"># Output: True</span>

nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]
<span class="comment"># Output: False</span></code></pre>
            </div>
          </div>
        </div>

        <div class="content-block fade-in">
          <h4>10. Mental Model (Lock This In)</h4>
          <div class="comparison-table">
            <table>
              <thead>
                <tr>
                  <th>Question</th>
                  <th>Ask Yourself</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Time</td>
                  <td>How many steps as n grows?</td>
                </tr>
                <tr>
                  <td>Space</td>
                  <td>How much extra memory as n grows?</td>
                </tr>
              </tbody>
            </table>
          </div>
          <div class="highlight-box">
            <p>
              <strong>Space complexity is the price you pay for speed.</strong>
            </p>
            <p>
              Good solutions balance both ‚Äî great solutions justify the
              tradeoff.
            </p>
          </div>
        </div>

        <div class="where-we-are fade-in">
          <h4>Where We Are Now</h4>
          <p>You now understand:</p>
          <ul>
            <li>What space complexity measures</li>
            <li>O(1) vs O(n) space</li>
            <li>The space-time tradeoff</li>
            <li>How recursion secretly uses memory</li>
          </ul>
          <p>This completes the foundations for algorithm analysis.</p>
        </div>

        <div class="what-next fade-in">
          <h4>What Comes Next</h4>
          <p>
            Now that you understand both time and space complexity, we're ready
            to explore our first dynamic data structure.
          </p>
          <div class="cta-button">
            <a href="#lesson-8">Start Lesson 8 ‚Üí</a>
          </div>
        </div>
      </article>

      <article id="lesson-8" data-lesson-section class="lesson">
        <div class="lesson-header">
          <span class="lesson-number">08</span>
          <h3 class="lesson-title">Linked Lists</h3>
          <p class="lesson-subtitle">Why They Exist</p>
        </div>

        <blockquote class="lesson-intro fade-in">
          Arrays are great for reading. Linked lists are great for writing.
        </blockquote>

        <div class="content-block fade-in">
          <h4>1. The Problem with Arrays</h4>
          <p>From Lesson 6, we learned:</p>
          <ul class="teaches-list">
            <li>
              <span class="bullet">‚Üí</span> Inserting into a sorted array ‚Üí
              <strong>O(n)</strong>
            </li>
            <li>
              <span class="bullet">‚Üí</span> Deleting from a sorted array ‚Üí
              <strong>O(n)</strong>
            </li>
          </ul>
          <p>Why? Because elements must shift.</p>
          <div class="core-idea">
            <p>What if we could insert and delete without shifting?</p>
          </div>
        </div>

        <div class="content-block fade-in">
          <h4>2. What Is a Linked List?</h4>
          <p>
            A linked list is a sequence of <strong>nodes</strong> where each
            node contains:
          </p>
          <ol style="margin-left: 1.5rem">
            <li><strong>Data</strong> ‚Äî the value</li>
            <li><strong>Pointer</strong> ‚Äî reference to the next node</li>
          </ol>
          <pre
            class="code-block"
          ><code>[5] ‚Üí [12] ‚Üí [8] ‚Üí [3] ‚Üí None</code></pre>
          <p>
            Unlike arrays, nodes are <strong>not stored contiguously</strong> in
            memory.
          </p>
        </div>

        <div class="content-block fade-in">
          <h4>3. Why This Matters</h4>
          <div class="space-checklist">
            <div class="space-yes">
              <h5>Arrays</h5>
              <ul>
                <li>Elements live side-by-side</li>
                <li>Inserting means shifting everything after</li>
              </ul>
            </div>
            <div class="space-no">
              <h5>Linked Lists</h5>
              <ul>
                <li>Elements can live anywhere in memory</li>
                <li>Inserting means updating pointers</li>
              </ul>
            </div>
          </div>
          <blockquote class="insight">No shifting required!</blockquote>
        </div>

        <div class="content-block fade-in">
          <h4>4. Linked List Node (Code)</h4>
          <pre
            class="code-block"
          ><code><span class="keyword">class</span> <span class="function">Node</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, value):
        self.value = value
        self.next = <span class="number">None</span></code></pre>
          <p>That's it. A node holds a value and points to the next node.</p>
        </div>

        <div class="content-block fade-in">
          <h4>5. Building a Simple Linked List</h4>
          <pre
            class="code-block"
          ><code><span class="comment"># Create nodes</span>
a = Node(<span class="number">5</span>)
b = Node(<span class="number">12</span>)
c = Node(<span class="number">8</span>)

<span class="comment"># Link them</span>
a.next = b
b.next = c

<span class="comment"># Result: 5 ‚Üí 12 ‚Üí 8 ‚Üí None</span></code></pre>
        </div>

        <div class="content-block fade-in">
          <h4>6. Traversing a Linked List</h4>
          <pre
            class="code-block"
          ><code><span class="keyword">def</span> <span class="function">print_list</span>(head):
    current = head
    <span class="keyword">while</span> current:
        <span class="function">print</span>(current.value)
        current = current.next</code></pre>
          <p>How it works:</p>
          <ul class="teaches-list">
            <li><span class="bullet">‚Üí</span> <code>current = head</code> ‚Äî Start at the first node</li>
            <li><span class="bullet">‚Üí</span> <code>while current:</code> ‚Äî Keep going until we hit <code>None</code> (the end)</li>
            <li><span class="bullet">‚Üí</span> <code>current = current.next</code> ‚Äî Move to the next node</li>
          </ul>
          <p>Think of it like walking through a chain ‚Äî start at the first link, follow the pointer to the next, repeat until there's no next link.</p>
          <div class="tradeoff-stats">
            <span class="stat">Time: <strong>O(n)</strong></span>
            <span class="stat">Space: <strong>O(1)</strong></span>
          </div>
        </div>

        <div class="content-block fade-in">
          <h4>7. Insertion ‚Äî The Big Win</h4>
          <p>To insert <code>99</code> after node <code>a</code> (which holds <code>5</code>):</p>
          <pre
            class="code-block"
          ><code>new_node = Node(<span class="number">99</span>)
new_node.next = a.next  <span class="comment"># Step 1: new_node points to what a pointed to (12)</span>
a.next = new_node       <span class="comment"># Step 2: a now points to new_node</span></code></pre>
          <p>Before: <code>5 ‚Üí 12 ‚Üí 8</code></p>
          <p>After: <code>5 ‚Üí 99 ‚Üí 12 ‚Üí 8</code></p>
          <div class="core-idea">
            <p><strong>Why this order?</strong> We must save the reference to <code>12</code> before overwriting <code>a.next</code>. If reversed, we'd lose the rest of the chain!</p>
          </div>
          <div class="big-o-reveal">
            <span class="big-o">O(1)</span>
            <span class="label">Just pointer updates ‚Äî no shifting!</span>
          </div>
        </div>

        <div class="content-block fade-in">
          <h4>8. Deletion ‚Äî Also Fast</h4>
          <p>To delete the node after <code>a</code>:</p>
          <pre class="code-block"><code>a.next = a.next.next</code></pre>
          <p>Before: <code>5 ‚Üí 99 ‚Üí 12 ‚Üí 8</code></p>
          <p>After: <code>5 ‚Üí 12 ‚Üí 8</code></p>
          <div class="big-o-reveal">
            <span class="big-o">O(1)</span>
            <span class="label">Deletion</span>
          </div>
        </div>

        <div class="content-block fade-in">
          <h4>9. The Tradeoff (Important!)</h4>
          <div class="comparison-table">
            <table>
              <thead>
                <tr>
                  <th>Operation</th>
                  <th>Array</th>
                  <th>Linked List</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Access by index</td>
                  <td>O(1)</td>
                  <td>O(n)</td>
                </tr>
                <tr>
                  <td>Insert at position</td>
                  <td>O(n)</td>
                  <td>O(1)*</td>
                </tr>
                <tr>
                  <td>Delete at position</td>
                  <td>O(n)</td>
                  <td>O(1)*</td>
                </tr>
                <tr>
                  <td>Search</td>
                  <td>O(n) or O(log n)</td>
                  <td>O(n)</td>
                </tr>
              </tbody>
            </table>
          </div>
          <p style="font-size: 0.9rem; opacity: 0.8">
            *If you already have a reference to the node.
          </p>
          <div class="core-idea">
            <p>
              Linked lists trade <strong>random access</strong> for
              <strong>fast modifications</strong>.
            </p>
          </div>
        </div>

        <div class="content-block fade-in">
          <h4>10. When to Use Linked Lists</h4>
          <div class="space-checklist">
            <div class="space-yes">
              <h5>Use Linked Lists When</h5>
              <ul>
                <li>Frequent insertions/deletions</li>
                <li>Size changes often</li>
                <li>You don't need random access</li>
              </ul>
            </div>
            <div class="space-no">
              <h5>Use Arrays When</h5>
              <ul>
                <li>Frequent lookups by index</li>
                <li>Data is mostly static</li>
                <li>You need binary search</li>
              </ul>
            </div>
          </div>
        </div>

        <div class="content-block fade-in">
          <h4>11. Types of Linked Lists</h4>
          <ol style="margin-left: 1.5rem">
            <li><strong>Singly Linked</strong> ‚Äî each node points to next</li>
            <li>
              <strong>Doubly Linked</strong> ‚Äî each node points to next AND
              previous
            </li>
            <li><strong>Circular</strong> ‚Äî last node points back to first</li>
          </ol>
          <p>We'll focus on singly linked lists for now.</p>
        </div>

        <div class="content-block fade-in">
          <h4>12. Key Takeaway</h4>
          <div class="highlight-box">
            <p>
              <strong
                >Arrays are optimized for reading. Linked lists are optimized
                for writing.</strong
              >
            </p>
            <p>Neither is "better" ‚Äî they solve different problems.</p>
          </div>
        </div>

        <div class="content-block fade-in">
          <h4>13. Mental Model</h4>
          <div class="comparison-table">
            <table>
              <thead>
                <tr>
                  <th>Question</th>
                  <th>Array</th>
                  <th>Linked List</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>How is data stored?</td>
                  <td>Contiguous</td>
                  <td>Scattered</td>
                </tr>
                <tr>
                  <td>Fast at?</td>
                  <td>Reading</td>
                  <td>Inserting/Deleting</td>
                </tr>
                <tr>
                  <td>Slow at?</td>
                  <td>Inserting/Deleting</td>
                  <td>Reading by index</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>

        <div class="content-block fade-in">
          <h4>14. LeetCode-Style Question (Lesson 8)</h4>
          <div class="practice-problem">
            <h5>Problem: Search in a Linked List</h5>
            <div class="problem-section">
              <p class="problem-label">Problem Statement</p>
              <p>
                Given the <code>head</code> of a singly linked list and a
                <code>target</code> value, return <code>True</code> if the value
                exists in the list. Otherwise, return <code>False</code>.
              </p>
            </div>
            <div class="problem-section">
              <p class="problem-label">Key Insight</p>
              <ul>
                <li>You must traverse the entire list</li>
                <li>No shortcuts (unlike binary search on arrays)</li>
              </ul>
            </div>
            <div class="problem-section">
              <p class="problem-label">Function Signature</p>
              <pre
                class="code-block"
              ><code><span class="keyword">def</span> <span class="function">search_linked_list</span>(head, target):
    <span class="keyword">pass</span></code></pre>
            </div>
            <div class="problem-section">
              <p class="problem-label">Example</p>
              <pre
                class="code-block"
              ><code><span class="comment"># List: 5 ‚Üí 12 ‚Üí 8 ‚Üí 3 ‚Üí None</span>

search_linked_list(head, <span class="number">8</span>)   <span class="comment"># Output: True</span>
search_linked_list(head, <span class="number">99</span>)  <span class="comment"># Output: False</span></code></pre>
            </div>
            <div class="problem-section">
              <p class="problem-label">Expected Complexity</p>
              <ul>
                <li>Time: O(n)</li>
                <li>Space: O(1)</li>
              </ul>
            </div>
          </div>
        </div>

        <div class="where-we-are fade-in">
          <h4>Where We Are Now</h4>
          <p>You now understand:</p>
          <ul>
            <li>Why linked lists exist</li>
            <li>How nodes and pointers work</li>
            <li>O(1) insertion and deletion</li>
            <li>The array vs linked list tradeoff</li>
          </ul>
        </div>

        <div class="what-next fade-in">
          <h4>What Comes Next</h4>
          <p>
            You're building the exact intuition strong DSA learners have. Next,
            we'll practice implementing linked list operations.
          </p>
        </div>
      </article>
    </main>

    <script src="../app.js"></script>
    <script src="../visualizations.js"></script>
  </body>
</html>
