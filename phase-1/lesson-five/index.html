<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Phase 1 ‚Ä¢ Lesson 5 | Sorted Arrays & Binary Search</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Outfit:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.2/lib/anime.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="stylesheet" href="../../styles.css" />
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body class="lesson-page">
    <aside
      class="course-drawer"
      id="courseDrawer"
      aria-label="Course navigation"
    >
      <div class="drawer-header">
        <span class="drawer-title">&lt;/&gt; DSA</span>
      </div>
      <div class="drawer-content">
        <div class="drawer-section" data-collapsible>
          <button class="drawer-section-toggle" aria-expanded="false">
            Phase 0: Foundations
            <span class="drawer-chevron" aria-hidden="true">‚ñæ</span>
          </button>
          <div class="drawer-links">
            <a href="../phase-0/index.html#lesson-1" class="drawer-link">
              Lesson 1: What is DSA?
            </a>
            <a href="../phase-0/index.html#lesson-2" class="drawer-link">
              Lesson 2: Time Complexity
            </a>
            <a href="../phase-0/index.html#lesson-3" class="drawer-link">
              Lesson 3: Arrays
            </a>
            <a href="../phase-0/index.html#lesson-4" class="drawer-link">
              Lesson 4: Linear Search
            </a>
          </div>
        </div>
        <div class="drawer-section" data-collapsible>
          <button class="drawer-section-toggle" aria-expanded="true">
            Phase 1: Core Structures
            <span class="drawer-chevron" aria-hidden="true">‚ñæ</span>
          </button>
          <div class="drawer-links">
            <a href="../phase-1/index.html" class="drawer-link">
              Phase 1: Sorted Arrays & Binary Search
            </a>
          </div>
        </div>
        <div class="drawer-section drawer-section-locked">
          <div class="drawer-section-label">Phase 2: Algorithms</div>
          <div class="drawer-section-status">Coming Soon</div>
        </div>
      </div>
    </aside>

    <main class="main-content">
      <section class="lesson-page-header">
        <span class="phase-badge">Phase 1</span>
        <h1 class="lesson-page-title">Sorted Arrays & Binary Search</h1>
        <p class="lesson-page-subtitle">
          To go faster, we must give something up.
        </p>
      </section>

      <article class="lesson lesson-alt">
        <div class="lesson-header">
          <span class="lesson-number">05</span>
          <h3 class="lesson-title">Sorted Arrays & Binary Search</h3>
          <p class="lesson-subtitle">
            To go faster, we must give something up.
          </p>
        </div>

        <blockquote class="lesson-intro fade-in">
          So far, we've been searching like this: "Check every element until we
          find it." That works ‚Äî but it's slow at scale. Binary search asks a
          different question: "What if the data were organized?"
        </blockquote>

        <div class="content-block fade-in">
          <h4>1. What Is Binary Search?</h4>
          <p>
            Binary search is a <strong>searching algorithm</strong> that works
            on sorted arrays.
          </p>
          <div class="core-idea">
            <p>
              It repeatedly divides the search space in half until the target is
              found (or proven not to exist).
            </p>
          </div>
          <p>The key insight:</p>
          <ul class="teaches-list">
            <li>
              <span class="bullet">‚Üí</span> Each comparison
              <strong>eliminates half the remaining elements</strong>
            </li>
            <li>
              <span class="bullet">‚Üí</span> This leads to O(log n) time
              complexity
            </li>
            <li>
              <span class="bullet">‚Üí</span> Vastly faster than linear search for
              large datasets
            </li>
          </ul>
        </div>

        <div class="content-block fade-in">
          <h4>2. The Cost of Speed (Important Trade-off)</h4>
          <p>Binary search only works if the array is sorted.</p>
          <pre
            class="code-block"
          ><code><span class="keyword">numbers</span> = [<span class="number">3</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">18</span>, <span class="number">25</span>, <span class="number">31</span>]</code></pre>
          <p>That's the price we pay:</p>
          <ul class="teaches-list">
            <li><span class="bullet">‚Üí</span> We must keep data sorted</li>
            <li><span class="bullet">‚Üí</span> Insertions become harder</li>
            <li>
              <span class="bullet">‚Üí</span> But searches become much faster
            </li>
          </ul>
          <div class="core-idea">
            <p>üëâ This is a classic DSA trade-off.</p>
          </div>
        </div>

        <div class="content-block fade-in">
          <h4>3. Intuition Before Code</h4>
          <p>Imagine guessing a number between 1 and 100.</p>
          <p>You don't start at 1. You guess 50.</p>
          <p>Then:</p>
          <ul class="teaches-list">
            <li><span class="bullet">‚Üí</span> If too high ‚Üí go left</li>
            <li><span class="bullet">‚Üí</span> If too low ‚Üí go right</li>
          </ul>
          <p>Each guess eliminates half the possibilities.</p>
          <blockquote class="insight">That's binary search.</blockquote>
        </div>

        <div class="content-block fade-in">
          <h4>4. How Binary Search Works (Step by Step)</h4>
          <p>Given:</p>
          <pre
            class="code-block"
          ><code><span class="keyword">numbers</span> = [<span class="number">3</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">18</span>, <span class="number">25</span>, <span class="number">31</span>]
<span class="keyword">target</span> = <span class="number">18</span></code></pre>
          <p>Steps:</p>
          <ol style="margin-left: 1.5rem">
            <li>Look at the middle element ‚Üí 18</li>
            <li>Is it the target?</li>
            <li>Yes ‚Üí done</li>
          </ol>
          <p>Worst case:</p>
          <ul class="teaches-list">
            <li><span class="bullet">‚Üí</span> You cut the array in half</li>
            <li><span class="bullet">‚Üí</span> Then in half again</li>
            <li><span class="bullet">‚Üí</span> Then again‚Ä¶</li>
          </ul>
        </div>

        <div class="content-block fade-in">
          <h4>5. Binary Search Code (Iterative)</h4>
          <pre
            class="code-block"
          ><code><span class="keyword">def</span> <span class="function">binary_search</span>(arr, target):
    left = <span class="number">0</span>
    right = <span class="function">len</span>(arr) - <span class="number">1</span>

    <span class="keyword">while</span> left &lt;= right:
        mid = (left + right) // <span class="number">2</span>

        <span class="keyword">if</span> arr[mid] == target:
            <span class="keyword">return</span> <span class="number">True</span>
        <span class="keyword">elif</span> arr[mid] &lt; target:
            left = mid + <span class="number">1</span>
        <span class="keyword">else</span>:
            right = mid - <span class="number">1</span>

    <span class="keyword">return</span> <span class="number">False</span></code></pre>
          <p>Don't worry about memorizing this. Focus on the idea.</p>

          <h5 style="margin-top: 1.5rem">Try It Yourself</h5>
          <p>
            Watch binary search in action. Click Play or Step through each
            comparison:
          </p>
          <div id="binary-search-viz"></div>
        </div>

        <div class="content-block fade-in">
          <h4>6. Time Complexity (Why This Is Powerful)</h4>
          <p>
            The power of binary search comes from how much work it removes at
            each step.
          </p>

          <h5>The Core Rule</h5>
          <p>
            Each step of binary search cuts the remaining search space in half.
          </p>
          <p>
            This is very different from linear search, which removes only one
            element at a time.
          </p>

          <h5>What "Cutting in Half" Looks Like</h5>
          <p>If an array has n elements:</p>
          <table
            style="width: 100%; border-collapse: collapse; margin: 1.5rem 0"
          >
            <tr style="border-bottom: 2px solid var(--border)">
              <th style="padding: 1rem; text-align: left; font-weight: 600">
                Step
              </th>
              <th style="padding: 1rem; text-align: left; font-weight: 600">
                Remaining
              </th>
              <th style="padding: 1rem; text-align: left; font-weight: 600">
                Example (n=1,024)
              </th>
              <th style="padding: 1rem; text-align: left; font-weight: 600">
                Visual
              </th>
            </tr>
            <tr
              style="
                background-color: rgba(59, 130, 246, 0.05);
                border-bottom: 1px solid var(--border);
              "
            >
              <td style="padding: 1rem">1</td>
              <td style="padding: 1rem; font-weight: 500">n / 2</td>
              <td style="padding: 1rem; font-family: monospace">512</td>
              <td style="padding: 1rem">
                <div
                  style="
                    height: 20px;
                    background: linear-gradient(
                      90deg,
                      #3b82f6 50%,
                      transparent 50%
                    );
                    border-radius: 3px;
                  "
                ></div>
              </td>
            </tr>
            <tr
              style="
                background-color: rgba(59, 130, 246, 0.03);
                border-bottom: 1px solid var(--border);
              "
            >
              <td style="padding: 1rem">2</td>
              <td style="padding: 1rem; font-weight: 500">n / 4</td>
              <td style="padding: 1rem; font-family: monospace">256</td>
              <td style="padding: 1rem">
                <div
                  style="
                    height: 20px;
                    background: linear-gradient(
                      90deg,
                      #3b82f6 25%,
                      transparent 25%
                    );
                    border-radius: 3px;
                  "
                ></div>
              </td>
            </tr>
            <tr
              style="
                background-color: rgba(59, 130, 246, 0.05);
                border-bottom: 1px solid var(--border);
              "
            >
              <td style="padding: 1rem">3</td>
              <td style="padding: 1rem; font-weight: 500">n / 8</td>
              <td style="padding: 1rem; font-family: monospace">128</td>
              <td style="padding: 1rem">
                <div
                  style="
                    height: 20px;
                    background: linear-gradient(
                      90deg,
                      #3b82f6 12.5%,
                      transparent 12.5%
                    );
                    border-radius: 3px;
                  "
                ></div>
              </td>
            </tr>
            <tr
              style="
                background-color: rgba(59, 130, 246, 0.03);
                border-bottom: 1px solid var(--border);
              "
            >
              <td style="padding: 1rem">4</td>
              <td style="padding: 1rem; font-weight: 500">n / 16</td>
              <td style="padding: 1rem; font-family: monospace">64</td>
              <td style="padding: 1rem">
                <div
                  style="
                    height: 20px;
                    background: linear-gradient(
                      90deg,
                      #3b82f6 6.25%,
                      transparent 6.25%
                    );
                    border-radius: 3px;
                  "
                ></div>
              </td>
            </tr>
            <tr style="color: var(--text-secondary)">
              <td style="padding: 1rem">‚Ä¶</td>
              <td style="padding: 1rem">‚Ä¶</td>
              <td style="padding: 1rem">‚Ä¶</td>
              <td style="padding: 1rem">‚Üí until 1</td>
            </tr>
          </table>
          <ul class="teaches-list">
            <li>
              <span class="bullet">‚Üí</span> You are not checking elements one by
              one.
            </li>
            <li>
              <span class="bullet">‚Üí</span> You are eliminating large portions
              immediately.
            </li>
          </ul>

          <h5>Concrete Example</h5>
          <p>If the array has 16 elements:</p>
          <pre class="code-block"><code>16 ‚Üí 8 ‚Üí 4 ‚Üí 2 ‚Üí 1</code></pre>
          <p>Binary search finishes in 4 steps.</p>
          <p>If the array has 1,024 elements:</p>
          <pre class="code-block"><code>1,024 ‚Üí 512 ‚Üí 256 ‚Üí ... ‚Üí 1</code></pre>
          <p>Binary search finishes in 10 steps.</p>

          <h5>What This Means for Performance</h5>
          <p>As input size grows:</p>
          <ul class="teaches-list">
            <li>
              <span class="bullet">‚Üí</span> Linear search work grows
              proportionally
            </li>
            <li>
              <span class="bullet">‚Üí</span> Binary search work grows very slowly
            </li>
          </ul>
          <p>Doubling the input size:</p>
          <ul class="teaches-list">
            <li><span class="bullet">‚ùå</span> Does NOT double the work</li>
            <li><span class="bullet">‚úÖ</span> Adds only one extra step</li>
          </ul>

          <h5>The Name for This Growth Pattern</h5>
          <p>This kind of growth is called logarithmic time, written as:</p>
          <div class="core-idea">
            <p>üëâ <strong>O(log n)</strong></p>
          </div>
          <p>You don't need to calculate logs.</p>
          <p>Just remember:</p>
          <blockquote class="insight">
            <strong>
              If an algorithm repeatedly cuts the problem in half, it's O(log
              n).</strong
            >
          </blockquote>
        </div>

        <div class="content-block fade-in">
          <h4>7. Compare Growth (This Is the "Wow" Moment)</h4>
          <table
            style="
              width: 100%;
              text-align: center;
              border-collapse: collapse;
              margin: 1rem 0;
            "
          >
            <tr style="border-bottom: 1px solid var(--border)">
              <th style="padding: 0.75rem">Elements</th>
              <th style="padding: 0.75rem">Linear Search (O(n))</th>
              <th style="padding: 0.75rem">Binary Search (O(log n))</th>
            </tr>
            <tr style="border-bottom: 1px solid var(--border)">
              <td style="padding: 0.75rem">10</td>
              <td style="padding: 0.75rem">10 checks</td>
              <td style="padding: 0.75rem">~4 checks</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--border)">
              <td style="padding: 0.75rem">1,000</td>
              <td style="padding: 0.75rem">1,000 checks</td>
              <td style="padding: 0.75rem">~10 checks</td>
            </tr>
            <tr>
              <td style="padding: 0.75rem">1,000,000</td>
              <td style="padding: 0.75rem">1,000,000 checks</td>
              <td style="padding: 0.75rem">~20 checks</td>
            </tr>
          </table>
          <p><strong>This is why binary search is famous.</strong></p>
        </div>

        <div class="content-block fade-in">
          <h4>8. Why Logarithmic Time Is So Fast</h4>
          <p>Because:</p>
          <ul class="teaches-list">
            <li>
              <span class="bullet">‚Üí</span> The problem size shrinks
              aggressively
            </li>
            <li><span class="bullet">‚Üí</span> Growth is extremely slow</li>
            <li>
              <span class="bullet">‚Üí</span> Doubling input size adds one extra
              step, not double work.
            </li>
          </ul>
        </div>

        <div class="content-block fade-in">
          <h4>9. Important Limitations (Don't Ignore These)</h4>
          <p>Binary search:</p>
          <ul class="teaches-list">
            <li>
              <span class="bullet">‚Üí</span> ‚ùå Does NOT work on unsorted data
            </li>
            <li><span class="bullet">‚Üí</span> ‚ùå Makes insertions expensive</li>
            <li>
              <span class="bullet">‚Üí</span> ‚ùå Requires random access (arrays)
            </li>
          </ul>
          <p>So again:</p>
          <blockquote class="insight">Speed comes with constraints.</blockquote>
        </div>

        <div class="content-block fade-in">
          <h4>10. Tiny Exercises (Think First)</h4>
          <div class="decides-grid">
            <div class="decides-card">
              <h5>Exercise 1</h5>
              <p>If an array has 1,024 elements:</p>
              <p>How many steps does binary search take (worst case)?</p>
            </div>
            <div class="decides-card">
              <h5>Exercise 2</h5>
              <p>Can binary search work on:</p>
              <ul>
                <li>A linked list?</li>
                <li>An unsorted list?</li>
              </ul>
              <p>Why or why not?</p>
            </div>
          </div>
        </div>

        <div class="content-block fade-in">
          <h4>11. Key Takeaway (Lock This In)</h4>
          <p>Binary search trades flexibility for speed.</p>
          <div class="decides-grid">
            <div class="decides-card">
              <h5>Linear Search</h5>
              <ul>
                <li>Works everywhere</li>
                <li>Scales poorly</li>
              </ul>
            </div>
            <div class="decides-card">
              <h5>Binary Search</h5>
              <ul>
                <li>Requires sorted data</li>
                <li>Scales incredibly well</li>
              </ul>
            </div>
          </div>
        </div>

        <div class="content-block fade-in">
          <h4>üß≠ Where We Are Now</h4>
          <p>You've now seen your first major algorithmic upgrade:</p>
          <ul class="teaches-list">
            <li><span class="bullet">‚Üí</span> Same data structure (array)</li>
            <li><span class="bullet">‚Üí</span> Drastically better algorithm</li>
          </ul>
          <blockquote class="insight">This is core DSA thinking.</blockquote>
        </div>

        <div class="content-block fade-in">
          <h4>üîú What Comes Next</h4>
          <p>Next, we look at the hidden cost of sorted arrays:</p>
          <blockquote class="question-quote">
            üëâ <strong>Phase 1 ‚Äì Lesson 6: Array Insertions & Deletions</strong>
          </blockquote>
          <p class="center-text">We'll explore why speed is never free.</p>
        </div>
      </article>
    </main>

    <script src="../../app.js"></script>
    <script src="../../visualizations.js"></script>
    <script src="script.js"></script>
  </body>
</html>
